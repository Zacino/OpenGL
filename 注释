    /*
        把OpenGL想象成一个工作台，上面有很多专用的“工位”。
        例如，有一个“专门处理顶点数据”的工位，一个“专门处理顶点绘制顺序”的工位等等。 
        调用draw指令的时候就会从设置的工位中画。
        glBindBuffer(GLenum target, GLuint buffer)
        函数的作用就是：把一个指定的“零件盒”（缓冲对象）放到一个指定的“工位”上。
        GLenum target:指定缓冲对象要绑定到的“工位”，即绑定点。这个参数告诉OpenGL你打算如何使用这个缓冲对象。
            GL_ARRAY_BUFFER: 这是最常用的目标。它用于指定包含顶点属性数据的缓冲。
            GL_ELEMENT_ARRAY_BUFFER: 它用于指定包含顶点索引的缓冲。
    */
    
    
    /**
     * 混合：当一个片段着色器输出颜色 srcColor 时，OpenGL 不会直接写到帧缓冲区，
     *          而是会跟缓冲区里原本的颜色 dstColor 按照规则混合，生成新的颜色。
     * 步骤：
     *      1:启动  glEnable(GL_BLEND);
     *      2:glBlendFunc(src, dst);    // 设置源和目标因子
     *                          GL_SRC_ALPHA → 值 = 源颜色的 alpha   
     *                          GL_ONE_MINUS_SRC_ALPHA → 值 = 1 - 源 alpha
     *      3:glBlendEquation(GL_FUNC_ADD); // 设置计算方法
                                GL_FUNC_SUBTRACT → src - dst
                                GL_FUNC_REVERSE_SUBTRACT → dst - src
     */
    GLCall(glEnable(GL_BLEND));
    GLCall(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA));
    


    /**
     * 局部空间：模型内部空间
     * 世界空间：整个场景的通用坐标系
     * 视图空间：相机视角
     * 裁剪空间：视图空间通过投影矩阵转到标准坐标系，并进行裁剪，剔除视野范围外的模型
     * 标准化设备空间NDC：裁剪空间的标准化[-1, 1]
     * 屏幕空间：NDC映射到最终屏幕
     * 
     * 虚拟窗口 (ortho) → 压缩到 NDC [-1,1] → 映射到真实窗口 (glViewport)。
     * 如果 ortho 的宽高比 = 窗口宽高比 → 图形不会被拉伸。
     * 
     * 模型矩阵 (Model Matrix)
     *      从局部空间转换到世界空间。
     *      由物体的平移 (Translation)、旋转 (Rotation) 和缩放 (Scaling) 操作组合而成。
     * 
     * 视图矩阵 (View Matrix)
     *      将物体从世界空间转换到视图空间。它模拟了摄像机（观察者）的位置和朝向。
     *      它是摄像机位置和朝向的逆变换。
     * 
     * 投影矩阵 (Projection Matrix)
     *      从视图空间转换到裁剪空间。
     *      透视投影 (Perspective Projection) / 正交投影 (Orthographic Projection)
     */
    glm::vec3 translation(200, 200, 0);
    glm::mat4 proj = glm::ortho(0.0f, 960.0f, 0.0f, 540.0f, -1.0f, 1.0f); //正交投影矩阵，定义了虚拟窗口的像素，会映射到屏幕上的窗口
    glm::mat4 view = glm::translate(glm::mat4(1.0f), glm::vec3(-100, 0, 0));// 视图矩阵